{
  "result": [
    {
      "topic": "Sorting_and_Searching",
      "questions": [
        {
          "question": "What is the primary goal of a sorting algorithm?",
          "options": {
            "A": "To find a specific element in a list.",
            "B": "To rearrange the elements of a list into a specific order (usually ascending or descending).",
            "C": "To remove duplicate elements from a list.",
            "D": "To determine the number of elements in a list."
          },
          "correct_answer": "B",
          "explanation": "Sorting algorithms organize data for more efficient searching and processing."
        },
        {
          "question": "What is 'Bubble Sort'?",
          "options": {
            "A": "A sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted.",
            "B": "A sorting algorithm that divides the input array into two sub-arrays: a sorted sub-array and an unsorted sub-array. It repeatedly selects the smallest (or largest) element from the unsorted sub-array and moves it to the sorted sub-array.",
            "C": "A sorting algorithm that builds the final sorted array (or list) one item at a time. It is much less efficient on large lists than more advanced algorithms such as quicksort, heapsort, or merge sort.",
            "D": "A divide and conquer sorting algorithm that works by selecting a 'pivot' element from the array and partitioning the other elements into two sub-arrays, according to whether they are less than or greater than the pivot."
          },
          "correct_answer": "A",
          "explanation": "Bubble sort is simple to implement but not very efficient for large datasets."
        },
        {
          "question": "What is 'Insertion Sort'?",
          "options": {
            "A": "A sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order.",
            "B": "A sorting algorithm that divides the input array into two sub-arrays: a sorted sub-array and an unsorted sub-array. It repeatedly selects the smallest (or largest) element from the unsorted sub-array and moves it to the sorted sub-array.",
            "C": "A sorting algorithm that builds the final sorted array (or list) one item at a time. It is much less efficient on large lists than more advanced algorithms such as quicksort, heapsort, or merge sort.",
            "D": "A divide and conquer sorting algorithm that works by selecting a 'pivot' element from the array and partitioning the other elements into two sub-arrays, according to whether they are less than or greater than the pivot."
          },
          "correct_answer": "C",
          "explanation": "Insertion sort is efficient for small datasets or nearly sorted data."
        },
        {
          "question": "What is 'Selection Sort'?",
          "options": {
            "A": "A sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order.",
            "B": "A sorting algorithm that divides the input array into two sub-arrays: a sorted sub-array and an unsorted sub-array. It repeatedly selects the smallest (or largest) element from the unsorted sub-array and moves it to the sorted sub-array.",
            "C": "A sorting algorithm that builds the final sorted array (or list) one item at a time.",
            "D": "A divide and conquer sorting algorithm that works by selecting a 'pivot' element from the array and partitioning the other elements into two sub-arrays, according to whether they are less than or greater than the pivot."
          },
          "correct_answer": "B",
          "explanation": "Selection sort is simple but generally less efficient than insertion sort for most cases."
        },
        {
          "question": "What is 'Merge Sort'?",
          "options": {
            "A": "A sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order.",
            "B": "A sorting algorithm that divides the input array into two sub-arrays: a sorted sub-array and an unsorted sub-array. It repeatedly selects the smallest (or largest) element from the unsorted sub-array and moves it to the sorted sub-array.",
            "C": "A sorting algorithm that builds the final sorted array (or list) one item at a time.",
            "D": "A divide and conquer sorting algorithm that works by recursively splitting the array into halves, sorting each half, and then merging the sorted halves."
          },
          "correct_answer": "D",
          "explanation": "Merge sort has a time complexity of O(n log n) and is stable."
        },
        {
          "question": "What is 'Quick Sort'?",
          "options": {
            "A": "A sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order.",
            "B": "A sorting algorithm that divides the input array into two sub-arrays: a sorted sub-array and an unsorted sub-array. It repeatedly selects the smallest (or largest) element from the unsorted sub-array and moves it to the sorted sub-array.",
            "C": "A sorting algorithm that builds the final sorted array (or list) one item at a time.",
            "D": "A divide and conquer sorting algorithm that works by selecting a 'pivot' element from the array and partitioning the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. The sub-arrays are then recursively sorted."
          },
          "correct_answer": "D",
          "explanation": "Quick sort has an average time complexity of O(n log n) and is often faster in practice than merge sort, but its worst-case time complexity is O(n^2)."
        },
        {
          "question": "What is 'Heap Sort'?",
          "options": {
            "A": "A sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order.",
            "B": "A sorting algorithm that divides the input array into two sub-arrays: a sorted sub-array and an unsorted sub-array. It repeatedly selects the smallest (or largest) element from the unsorted sub-array and moves it to the sorted sub-array.",
            "C": "A sorting algorithm that builds the final sorted array (or list) one item at a time.",
            "D": "A comparison-based sorting algorithm that uses a binary heap data structure. It is similar to selection sort where we first find the maximum (or minimum) element and place it at the end (or beginning) of the sorted array. We repeat the same process for the remaining elements."
          },
          "correct_answer": "D",
          "explanation": "Heap sort has a time complexity of O(n log n) and is an in-place sorting algorithm."
        },
        {
          "question": "What is the time complexity of Bubble Sort in the worst-case scenario?",
          "options": {
            "A": "O(n)",
            "B": "O(n log n)",
            "C": "O(n^2)",
            "D": "O(log n)"
          },
          "correct_answer": "C",
          "explanation": "In the worst case (reverse sorted array), every element needs to be compared with every other element."
        },
        {
          "question": "What is the time complexity of Merge Sort in the worst-case scenario?",
          "options": {
            "A": "O(n)",
            "B": "O(n log n)",
            "C": "O(n^2)",
            "D": "O(log n)"
          },
          "correct_answer": "B",
          "explanation": "Merge sort consistently divides the array and merges in O(n log n) time regardless of the initial order."
        },
        {
          "question": "What is the average time complexity of Quick Sort?",
          "options": {
            "A": "O(n)",
            "B": "O(n log n)",
            "C": "O(n^2)",
            "D": "O(log n)"
          },
          "correct_answer": "B",
          "explanation": "With a good pivot selection strategy, quicksort performs very well on average."
        },
        {
          "question": "What is the space complexity of Merge Sort?",
          "options": {
            "A": "O(1)",
            "B": "O(log n)",
            "C": "O(n)",
            "D": "O(n log n)"
          },
          "correct_answer": "C",
          "explanation": "Merge sort requires auxiliary space for merging the subarrays."
        },
        {
          "question": "What is the space complexity of Heap Sort?",
          "options": {
            "A": "O(1)",
            "B": "O(log n)",
            "C": "O(n)",
            "D": "O(n log n)"
          },
          "correct_answer": "A",
          "explanation": "Heap sort is an in-place sorting algorithm, requiring only a constant amount of extra space."
        },
        {
          "question": "What is a 'stable' sorting algorithm?",
          "options": {
            "A": "A sorting algorithm that always runs in O(n log n) time.",
            "B": "A sorting algorithm that preserves the relative order of elements with equal values.",
            "C": "A sorting algorithm that sorts in descending order.",
            "D": "A sorting algorithm that has a space complexity of O(1)."
          },
          "correct_answer": "B",
          "explanation": "Stability can be important when sorting based on multiple criteria."
        },
        {
          "question": "Which of the following sorting algorithms is stable?",
          "options": {
            "A": "Quick Sort",
            "B": "Heap Sort",
            "C": "Merge Sort",
            "D": "Selection Sort"
          },
          "correct_answer": "C",
          "explanation": "Merge sort can be implemented to be stable."
        },
        {
          "question": "What is the primary goal of a searching algorithm?",
          "options": {
            "A": "To arrange elements in a specific order.",
            "B": "To find the location of a specific element within a data structure.",
            "C": "To count the number of elements in a data structure.",
            "D": "To remove elements from a data structure."
          },
          "correct_answer": "B",
          "explanation": "Searching algorithms are fundamental for retrieving information."
        },
        {
          "question": "What is 'Linear Search'?",
          "options": {
            "A": "A search algorithm that works by repeatedly dividing the search interval in half.",
            "B": "A search algorithm that starts at the beginning of a list and sequentially checks each element until the target element is found or the end of the list is reached.",
            "C": "A search algorithm that requires the data to be sorted.",
            "D": "A search algorithm that uses a hash function to find the element."
          },
          "correct_answer": "B",
          "explanation": "Linear search is simple but inefficient for large unsorted lists."
        },
        {
          "question": "What is 'Binary Search'?",
          "options": {
            "A": "A search algorithm that starts at the beginning of a list and sequentially checks each element.",
            "B": "A search algorithm that works by repeatedly dividing the search interval in half. It requires the data to be sorted.",
            "C": "A search algorithm that uses a hash function to directly access the element.",
            "D": "A search algorithm that is efficient for unsorted data."
          },
          "correct_answer": "B",
          "explanation": "Binary search is very efficient for searching in sorted data."
        },
        {
          "question": "What is the time complexity of Linear Search in the worst-case scenario?",
          "options": {
            "A": "O(1)",
            "B": "O(log n)",
            "C": "O(n)",
            "D": "O(n log n)"
          },
          "correct_answer": "C",
          "explanation": "In the worst case, the target element is the last element or not present in the list."
        },
        {
          "question": "What is the time complexity of Binary Search in the worst-case scenario?",
          "options": {
            "A": "O(1)",
            "B": "O(log n)",
            "C": "O(n)",
            "D": "O(n log n)"
          },
          "correct_answer": "B",
          "explanation": "Binary search halves the search space in each step."
        },
        {
          "question": "For which type of data is Binary Search applicable?",
          "options": {
            "A": "Unsorted data.",
            "B": "Data stored in a linked list.",
            "C": "Sorted data (typically in an array-like structure for efficient indexing).",
            "D": "Data stored in a hash table."
          },
          "correct_answer": "C",
          "explanation": "Binary search relies on the sorted property to efficiently narrow down the search space."
        }
      ]
    }
  ]
}
