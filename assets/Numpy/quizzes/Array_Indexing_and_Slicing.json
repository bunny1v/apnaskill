{
  "result": [
    {
      "topic": "Array_Indexing_and_Slicing",
      "questions": [
        {
          "question": "How do you access the element at the first row and first column of a 2D NumPy array named `data`?",
          "options": {
            "A": "data[0][0]",
            "B": "data(0, 0)",
            "C": "data[1, 1]",
            "D": "data{0, 0}"
          },
          "correct_answer": "A"
        },
        {
          "question": "What does negative indexing in NumPy arrays allow you to do?",
          "options": {
            "A": "Access elements with negative values.",
            "B": "Access elements from the end of the array.",
            "C": "Create a reversed copy of the array.",
            "D": "Skip elements during slicing."
          },
          "correct_answer": "B"
        },
        {
          "question": "For a 1D NumPy array `arr = [10, 20, 30, 40, 50]`, what is the result of `arr[-2]`?",
          "options": {
            "A": "10",
            "B": "40",
            "C": "50",
            "D": "IndexError"
          },
          "correct_answer": "B"
        },
        {
          "question": "Given a 2D NumPy array `matrix`, how would you extract the entire first row?",
          "options": {
            "A": "matrix[0]",
            "B": "matrix[:, 0]",
            "C": "matrix[0, :]",
            "D": "matrix(0)"
          },
          "correct_answer": "A"
        },
        {
          "question": "Given a 2D NumPy array `matrix`, how would you extract the entire first column?",
          "options": {
            "A": "matrix[0]",
            "B": "matrix[:, 0]",
            "C": "matrix[0, :]",
            "D": "matrix(:, 1)"
          },
          "correct_answer": "B"
        },
        {
          "question": "For a 1D NumPy array `arr = [2, 4, 6, 8, 10]`, what is the result of `arr[1:4]`?",
          "options": {
            "A": "[2, 4, 6]",
            "B": "[4, 6, 8]",
            "C": "[4, 6, 8, 10]",
            "D": "[2, 4, 6, 8]"
          },
          "correct_answer": "B"
        },
        {
          "question": "What does the step value in array slicing (e.g., `arr[start:stop:step]`) control?",
          "options": {
            "A": "The starting index of the slice.",
            "B": "The ending index of the slice (exclusive).",
            "C": "The increment between indices in the slice.",
            "D": "The number of elements to include in the slice."
          },
          "correct_answer": "C"
        },
        {
          "question": "For a 1D NumPy array `arr = [1, 2, 3, 4, 5]`, what is the result of `arr[::2]`?",
          "options": {
            "A": "[1, 2, 3, 4, 5]",
            "B": "[2, 4]",
            "C": "[1, 3, 5]",
            "D": "[5, 3, 1]"
          },
          "correct_answer": "C"
        },
        {
          "question": "How can you reverse a 1D NumPy array `arr` using slicing?",
          "options": {
            "A": "arr.reverse()",
            "B": "arr[::-1]",
            "C": "arr.slice(None, None, -1)",
            "D": "numpy.flip(arr)"
          },
          "correct_answer": "B"
        },
        {
          "question": "What is boolean indexing used for in NumPy arrays?",
          "options": {
            "A": "Accessing elements based on their position.",
            "B": "Selecting elements based on a boolean array of the same shape.",
            "C": "Converting array elements to boolean type.",
            "D": "Checking if an array is empty."
          },
          "correct_answer": "B"
        },
        {
          "question": "Given `arr = np.array([1, 2, 3, 4, 5])` and `mask = np.array([True, False, True, False, True])`, what is the result of `arr[mask]`?",
          "options": {
            "A": "[True, False, True, False, True]",
            "B": "[1, 3, 5]",
            "C": "[2, 4]",
            "D": "[1, 2, 3, 4, 5]"
          },
          "correct_answer": "B"
        },
        {
          "question": "What is fancy indexing in NumPy?",
          "options": {
            "A": "Indexing with negative numbers.",
            "B": "Indexing with a single scalar value.",
            "C": "Indexing with integer arrays to select elements at specific indices.",
            "D": "Indexing multi-dimensional arrays."
          },
          "correct_answer": "C"
        },
        {
          "question": "Given `arr = np.array([10, 20, 30, 40, 50])` and `indices = np.array([0, 3, 1])`, what is the result of `arr[indices]`?",
          "options": {
            "A": "[10, 20, 30]",
            "B": "[10, 40, 20]",
            "C": "[0, 3, 1]",
            "D": "[50, 40, 30]"
          },
          "correct_answer": "B"
        },
        {
          "question": "Can fancy indexing be used to modify array elements?",
          "options": {
            "A": "No, it only allows for reading elements.",
            "B": "Yes, you can assign new values to the selected elements.",
            "C": "Only for 1D arrays.",
            "D": "Only for boolean indexing."
          },
          "correct_answer": "B"
        },
        {
          "question": "Given a 2D array `data`, how would you select the elements at the intersections of rows [0, 2] and columns [1, 3] using fancy indexing?",
          "options": {
            "A": "data[[0, 2], [1, 3]]",
            "B": "data[[0, 1], [2, 3]]",
            "C": "data[0:3:2, 1:4:2]",
            "D": "data[np.ix_([0, 2], [1, 3])]"
          },
          "correct_answer": "A"
        },
        {
          "question": "What is the difference between `arr[1:3]` and `arr[[1, 2]]` for a 1D array `arr`?",
          "options": {
            "A": "They produce the same result.",
            "B": "`arr[1:3]` returns a slice (a view), while `arr[[1, 2]]` returns a copy (using fancy indexing).",
            "C": "`arr[1:3]` uses boolean indexing, while `arr[[1, 2]]` uses integer indexing.",
            "D": "`arr[1:3]` includes the element at index 3, while `arr[[1, 2]]` does not."
          },
          "correct_answer": "B"
        },
        {
          "question": "How can you select all elements in a 2D array `matrix` where the second column is greater than 5?",
          "options": {
            "A": "matrix[matrix[:, 1] > 5]",
            "B": "matrix[:, matrix[1] > 5]",
            "C": "matrix[matrix[1, :] > 5]",
            "D": "matrix(where(matrix[:, 1] > 5))"
          },
          "correct_answer": "A"
        },
        {
          "question": "What happens if you try to index a NumPy array with an index that is out of bounds?",
          "options": {
            "A": "The array is resized automatically.",
            "B": "It returns the last element.",
            "C": "It raises an IndexError.",
            "D": "It returns 0."
          },
          "correct_answer": "C"
        },
        {
          "question": "Can you use a list of boolean values for indexing a NumPy array?",
          "options": {
            "A": "No, only NumPy arrays of booleans are allowed.",
            "B": "Yes, Python lists of booleans are automatically converted to NumPy boolean arrays for indexing.",
            "C": "Only for 1D arrays.",
            "D": "Only if the list has the same length as the array."
          },
          "correct_answer": "B"
        },
        {
          "question": "Given a 3D array `tensor`, how would you access the element at the first 'layer', second row, and third column?",
          "options": {
            "A": "tensor[1, 2, 3]",
            "B": "tensor[0][1][2]",
            "C": "tensor(0, 1, 2)",
            "D": "Both A and B"
          },
          "correct_answer": "D"
        }
      ]
    }
  ]
}
